"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoftCrudRepository = void 0;
const repository_1 = require("@loopback/repository");
const rest_1 = require("@loopback/rest");
class SoftCrudRepository extends repository_1.DefaultCrudRepository {
    constructor(entityClass, dataSource, getCurrentUser) {
        super(entityClass, dataSource);
        this.getCurrentUser = getCurrentUser;
    }
    find(filter, options) {
        var _a;
        // Filter out soft deleted entries
        if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.and &&
            filter.where.and.length > 0) {
            filter.where.and.push({
                deleted: false,
            });
        }
        else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.or &&
            filter.where.or.length > 0) {
            filter.where = {
                and: [
                    {
                        deleted: false,
                    },
                    {
                        or: filter.where.or,
                    },
                ],
            };
        }
        else {
            filter = filter !== null && filter !== void 0 ? filter : {};
            filter.where = (_a = filter.where) !== null && _a !== void 0 ? _a : {};
            filter.where.deleted = false;
        }
        // Now call super
        return super.find(filter, options);
    }
    //find all enteries including soft deleted records
    findAll(filter, options) {
        return super.find(filter, options);
    }
    findOne(filter, options) {
        var _a;
        // Filter out soft deleted entries
        if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.and &&
            filter.where.and.length > 0) {
            filter.where.and.push({
                deleted: false,
            });
        }
        else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.or &&
            filter.where.or.length > 0) {
            filter.where = {
                and: [
                    {
                        deleted: false,
                    },
                    {
                        or: filter.where.or,
                    },
                ],
            };
        }
        else {
            filter = filter !== null && filter !== void 0 ? filter : {};
            filter.where = (_a = filter.where) !== null && _a !== void 0 ? _a : {};
            filter.where.deleted = false;
        }
        // Now call super
        return super.findOne(filter, options);
    }
    //findOne() including soft deleted entry
    findOneIncludeSoftDelete(filter, options) {
        return super.findOne(filter, options);
    }
    //To find the primary key/Unique Id field name
    getPkFieldName() {
        const data = this.entityClass.definition.properties;
        let pk = 'id';
        for (const key in data) {
            // eslint-disable-next-line no-prototype-builtins
            if (data.hasOwnProperty(key)) {
                const value = data[key];
                if (value.id) {
                    pk = key;
                    break;
                }
            }
        }
        return pk;
    }
    async findById(id, filter, options) {
        const pk = this.getPkFieldName();
        // Filter out soft deleted entries
        if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.and &&
            filter.where.and.length > 0) {
            filter.where.and.push({
                deleted: false,
                [pk]: id,
            });
        }
        else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
            filter.where.or &&
            filter.where.or.length > 0) {
            filter.where = {
                and: [
                    {
                        deleted: false,
                        [pk]: id,
                    },
                    {
                        or: filter.where.or,
                    },
                ],
            };
        }
        else {
            filter = filter !== null && filter !== void 0 ? filter : {};
            filter.where = {
                deleted: false,
                [pk]: id,
            };
        }
        //As parent method findById have filter: FilterExcludingWhere<T>
        //so we need add check here.
        const entityToRemove = await super.findOne(filter, options);
        if (entityToRemove) {
            // Now call super
            return super.findById(id, filter, options);
        }
        else {
            throw new rest_1.HttpErrors.NotFound("EntityNotFound" /* ErrorKeys.EntityNotFound */);
        }
    }
    //find by Id including soft deleted record
    async findByIdIncludeSoftDelete(id, filter, options) {
        //As parent method findById have filter: FilterExcludingWhere<T>
        //so we need add check here.
        const entityToRemove = await super.findOne(filter, options);
        if (entityToRemove) {
            // Now call super
            return super.findById(id, filter, options);
        }
        else {
            throw new rest_1.HttpErrors.NotFound("EntityNotFound" /* ErrorKeys.EntityNotFound */);
        }
    }
    updateAll(data, where, options) {
        // Filter out soft deleted entries
        if (where &&
            where.and &&
            where.and.length > 0) {
            where.and.push({
                deleted: false,
            });
        }
        else if (where &&
            where.or &&
            where.or.length > 0) {
            where = {
                and: [
                    {
                        deleted: false,
                    },
                    {
                        or: where.or,
                    },
                ],
            };
        }
        else {
            where = where !== null && where !== void 0 ? where : {};
            where.deleted = false;
        }
        // Now call super
        return super.updateAll(data, where, options);
    }
    count(where, options) {
        // Filter out soft deleted entries
        if (where &&
            where.and &&
            where.and.length > 0) {
            where.and.push({
                deleted: false,
            });
        }
        else if (where &&
            where.or &&
            where.or.length > 0) {
            where = {
                and: [
                    {
                        deleted: false,
                    },
                    {
                        or: where.or,
                    },
                ],
            };
        }
        else {
            where = where !== null && where !== void 0 ? where : {};
            where.deleted = false;
        }
        // Now call super
        return super.count(where, options);
    }
    async delete(entity, options) {
        // Do soft delete, no hard delete allowed
        entity.deleted = true;
        entity.deletedOn = new Date();
        entity.deletedBy = await this.getUserId();
        return super.update(entity, options);
    }
    async deleteAll(where, options) {
        // Do soft delete, no hard delete allowed
        return this.updateAll({
            deleted: true,
            deletedOn: new Date(),
            deletedBy: await this.getUserId(),
        }, where, options);
    }
    async deleteById(id, options) {
        // Do soft delete, no hard delete allowed
        return super.updateById(id, {
            deleted: true,
            deletedOn: new Date(),
            deletedBy: await this.getUserId(),
        }, options);
    }
    /**
     * Method to perform hard delete of entries. Take caution.
     * @param entity
     * @param options
     */
    deleteHard(entity, options) {
        // Do hard delete
        return super.deleteById(entity.getId(), options);
    }
    /**
     * Method to perform hard delete of entries. Take caution.
     * @param entity
     * @param options
     */
    deleteAllHard(where, options) {
        // Do hard delete
        return super.deleteAll(where, options);
    }
    /**
     * Method to perform hard delete of entries. Take caution.
     * @param entity
     * @param options
     */
    deleteByIdHard(id, options) {
        // Do hard delete
        return super.deleteById(id, options);
    }
    async getUserId(options) {
        if (!this.getCurrentUser) {
            return undefined;
        }
        let currentUser = await this.getCurrentUser();
        currentUser = currentUser !== null && currentUser !== void 0 ? currentUser : options === null || options === void 0 ? void 0 : options.currentUser;
        if (!currentUser || !currentUser.id) {
            return undefined;
        }
        return currentUser.id.toString();
    }
}
exports.SoftCrudRepository = SoftCrudRepository;
//# sourceMappingURL=soft-crud.repository.base.js.map