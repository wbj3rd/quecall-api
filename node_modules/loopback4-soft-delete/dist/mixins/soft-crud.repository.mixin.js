"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoftCrudRepositoryMixin = void 0;
const rest_1 = require("@loopback/rest");
function SoftCrudRepositoryMixin(base) {
    class SoftCrudRepository extends base {
        find(filter, options) {
            var _a;
            // Filter out soft deleted entries
            if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.and &&
                filter.where.and.length > 0) {
                filter.where.and.push({
                    deleted: false,
                });
            }
            else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.or &&
                filter.where.or.length > 0) {
                filter.where = {
                    and: [
                        {
                            deleted: false,
                        },
                        {
                            or: filter.where.or,
                        },
                    ],
                };
            }
            else {
                filter = filter !== null && filter !== void 0 ? filter : {};
                filter.where = (_a = filter.where) !== null && _a !== void 0 ? _a : {};
                filter.where.deleted = false;
            }
            // Now call super
            return super.find(filter, options);
        }
        findAll(filter, options) {
            return super.find(filter, options);
        }
        findOne(filter, options) {
            var _a;
            // Filter out soft deleted entries
            if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.and &&
                filter.where.and.length > 0) {
                filter.where.and.push({
                    deleted: false,
                });
            }
            else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.or &&
                filter.where.or.length > 0) {
                filter.where = {
                    and: [
                        {
                            deleted: false,
                        },
                        {
                            or: filter.where.or,
                        },
                    ],
                };
            }
            else {
                filter = filter !== null && filter !== void 0 ? filter : {};
                filter.where = (_a = filter.where) !== null && _a !== void 0 ? _a : {};
                filter.where.deleted = false;
            }
            // Now call super
            return super.findOne(filter, options);
        }
        //findOne() including soft deleted entry
        findOneIncludeSoftDelete(filter, options) {
            return super.findOne(filter, options);
        }
        async findById(id, filter, options) {
            // Filter out soft deleted entries
            if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.and &&
                filter.where.and.length > 0) {
                filter.where.and.push({
                    deleted: false,
                    id: id,
                });
            }
            else if ((filter === null || filter === void 0 ? void 0 : filter.where) &&
                filter.where.or &&
                filter.where.or.length > 0) {
                filter.where = {
                    and: [
                        {
                            deleted: false,
                            id: id,
                        },
                        {
                            or: filter.where.or,
                        },
                    ],
                };
            }
            else {
                filter = filter !== null && filter !== void 0 ? filter : {};
                filter.where = {
                    deleted: false,
                    id: id,
                };
            }
            //As parent method findById have filter: FilterExcludingWhere<E>
            //so we need add check here.
            const entityToRemove = await super.findOne(filter, options);
            if (entityToRemove) {
                // Now call super
                return super.findById(id, filter, options);
            }
            else {
                throw new rest_1.HttpErrors.NotFound("EntityNotFound" /* ErrorKeys.EntityNotFound */);
            }
        }
        //find by Id including soft deleted record
        async findByIdIncludeSoftDelete(id, filter, options) {
            //As parent method findById have filter: FilterExcludingWhere<E>
            //so we need add check here.
            const entityToRemove = await super.findOne(filter, options);
            if (entityToRemove) {
                // Now call super
                return super.findById(id, filter, options);
            }
            else {
                throw new rest_1.HttpErrors.NotFound("EntityNotFound" /* ErrorKeys.EntityNotFound */);
            }
        }
        updateAll(data, where, options) {
            // Filter out soft deleted entries
            if (where &&
                where.and &&
                where.and.length > 0) {
                where.and.push({
                    deleted: false,
                });
            }
            else if (where &&
                where.or &&
                where.or.length > 0) {
                where = {
                    and: [
                        {
                            deleted: false,
                        },
                        {
                            or: where.or,
                        },
                    ],
                };
            }
            else {
                where = where !== null && where !== void 0 ? where : {};
                where.deleted = false;
            }
            // Now call super
            return super.updateAll(data, where, options);
        }
        count(where, options) {
            // Filter out soft deleted entries
            if (where &&
                where.and &&
                where.and.length > 0) {
                where.and.push({
                    deleted: false,
                });
            }
            else if (where &&
                where.or &&
                where.or.length > 0) {
                where = {
                    and: [
                        {
                            deleted: false,
                        },
                        {
                            or: where.or,
                        },
                    ],
                };
            }
            else {
                where = where !== null && where !== void 0 ? where : {};
                where.deleted = false;
            }
            // Now call super
            return super.count(where, options);
        }
        async delete(entity, options) {
            // Do soft delete, no hard delete allowed
            entity.deleted = true;
            entity.deletedOn = new Date();
            entity.deletedBy = await this.getUserId(this.getCurrentUser);
            return super.update(entity, options);
        }
        async deleteAll(where, options) {
            // Do soft delete, no hard delete allowed
            return this.updateAll({
                deleted: true,
                deletedOn: new Date(),
                deletedBy: await this.getUserId(this.getCurrentUser),
            }, where, options);
        }
        async deleteById(id, options) {
            // Do soft delete, no hard delete allowed
            return super.updateById(id, {
                deleted: true,
                deletedOn: new Date(),
                deletedBy: await this.getUserId(this.getCurrentUser),
            }, options);
        }
        /**
         * Method to perform hard delete of entries. Take caution.
         * @param entity
         * @param options
         */
        deleteHard(entity, options) {
            // Do hard delete
            return super.deleteById(entity.getId(), options);
        }
        /**
         * Method to perform hard delete of entries. Take caution.
         * @param entity
         * @param options
         */
        deleteAllHard(where, options) {
            // Do hard delete
            return super.deleteAll(where, options);
        }
        /**
         * Method to perform hard delete of entries. Take caution.
         * @param entity
         * @param options
         */
        deleteByIdHard(id, options) {
            // Do hard delete
            return super.deleteById(id, options);
        }
        async getUserId(options) {
            if (!this.getCurrentUser) {
                return undefined;
            }
            let currentUser = await this.getCurrentUser();
            currentUser = currentUser !== null && currentUser !== void 0 ? currentUser : options === null || options === void 0 ? void 0 : options.currentUser;
            if (!currentUser || !currentUser.id) {
                return undefined;
            }
            return currentUser.id.toString();
        }
    }
    return SoftCrudRepository;
}
exports.SoftCrudRepositoryMixin = SoftCrudRepositoryMixin;
//# sourceMappingURL=soft-crud.repository.mixin.js.map